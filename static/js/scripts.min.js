'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var tasks = [{
    id: 0,
    entryTimestamp: 1614010031296,
    taskTitle: 'Title 1',
    taskMessage: 'Message 1',
    taskMarker: 'gray'
}, {
    id: 1,
    entryTimestamp: 1614010031396,
    taskTitle: 'Title 2',
    taskMessage: 'Message 2',
    taskMarker: 'green'
}, {
    id: 2,
    entryTimestamp: 1614010031696,
    taskTitle: 'Title 3',
    taskMessage: 'Message 3',
    taskMarker: 'red'
}];

var editingItemId = void 0;
var dateSort = 'newest';

var getItemData = function getItemData() {

    var form = document.querySelector('.js_form');

    form.addEventListener('submit', function (e) {

        e.preventDefault();
        var formData = Object.fromEntries(new FormData(e.target));
        var timestamp = new Date().getTime();

        if (editingItemId >= 0) {

            // we are editing an existing item
            // find the item in the tasks array by the id
            // create a new object with updated properties (new property: lastEditTimestamp)
            // overwrite the data in tasks[entryIndex]


            var entryIndex = tasks.findIndex(function (x) {
                return x.id === editingItemId;
            });

            var editedObject = _extends({
                id: editingItemId,
                entryTimestamp: tasks[entryIndex].entryTimestamp,
                lastEditTimestamp: timestamp
            }, formData);

            tasks[entryIndex] = editedObject;

            console.log('DATA FOR SERVER - UPDATE');
            console.log('\n                const url = \'https://someurl.com/tasks/2\';\n                const data = {\n                    id: 2,\n                    entryTimeStamp: 1614156855456,\n                    lastEditTimestamp: 1614156860000,\n                    taskTitle: \'Some title\',\n                    taskMessage: \'Some message\',\n                    taskMarker: \'red\'\n                };\n                fetch(url, {\n                    method: \'PATCH\',\n                    headers: {\n                        \'Content-Type: \'application/json; charset=UTF-8\'\n                    },\n                    body: JSON.stringify(data)\n                });\n            ');
        } else {

            // we are creating a new item
            // set the id and entryTimestamp
            // spread the data from the form elements

            var newObject = _extends({
                id: tasks.length,
                entryTimestamp: timestamp
            }, formData);

            // if entryDate === 'newest' the item is pushed to the end of tasksArray
            // if entryDate === 'oldest' the item is added to the beginning od the tasksArray

            if (dateSort === 'newest') {
                tasks.push(newObject);
            } else {
                tasks.unshift(newObject);
                console.log('tasks', tasks);
            }

            console.log('DATA FOR SERVER - NEW ENTRY');
            console.log('\n                const url = \'https://someurl.com/tasks\';\n                const data = {\n                    id: 3,\n                    entryTimeStamp: 1614156855456,\n                    taskTitle: \'Some title\',\n                    taskMessage: \'Some message\',\n                    taskMarker: \'red\'\n                };\n                fetch(url, {\n                    method: \'POST\',\n                    headers: {\n                        \'Content-Type: \'application/json; charset=UTF-8\'\n                    },\n                    body: JSON.stringify(data)\n                });\n            ');
        }

        buildItemList();

        // reset the form
        e.target.reset();
    });
};

var buildItemList = function buildItemList() {
    var rebuild = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


    var itemsWrapper = document.querySelector('.js_tasksWrapper');

    if (rebuild) {

        // repopulate the itemsWrapper element - was previously emptyed in filterResults()

        tasks.forEach(function (task) {

            var markupInnerHtml = createTaskInnerMarkup(task);

            var markup = document.createElement('div');
            markup.className = 'task is-' + task.taskMarker;
            markup.dataset.id = task.id;

            markup.innerHTML = markupInnerHtml;

            itemsWrapper.prepend(markup);
        });

        return;
    }

    if (editingItemId >= 0) {

        // we are editing an existing entry
        // find an existing element in the DOM and an existing item in the tasks array using the editingItemId
        // change/update the markers class
        // update the existing element innerHTML
        // we are done editing, set the ediitingItemId to undefined

        var existingElement = itemsWrapper.querySelector('[data-id="' + editingItemId + '"');
        var existingItem = tasks.find(function (x) {
            return x.id === editingItemId;
        });
        existingElement.className = 'task is-' + existingItem.taskMarker;
        existingElement.innerHTML = createTaskInnerMarkup(existingItem);

        editingItemId = undefined;

        return;
    }

    // we are adding the last entry of tasks array if entryDate sorting is set to 'newest', or first entry if it is set to 'oldest'

    var newItem = void 0;
    if (dateSort === 'newest') {
        newItem = tasks[tasks.length - 1];
    } else {
        newItem = tasks[0];
    }

    // create new div, add classes and data-id to id and fill it up with inner content

    var taskElement = document.createElement('div');
    taskElement.className = 'task is-' + newItem.taskMarker;
    taskElement.dataset.id = tasks.length - 1;

    taskElement.innerHTML = createTaskInnerMarkup(newItem);

    // if entryDate === 'newest' the item is prepended to the beginning
    // if entryDate === 'oldest' the item is appended to the end

    if (dateSort === 'newest') {
        itemsWrapper.prepend(taskElement);
    } else {
        itemsWrapper.append(taskElement);
    }
};

var createTaskInnerMarkup = function createTaskInnerMarkup(item) {

    // return the inner markup for a single task

    return '\n        <div class="task__inner_wrap">\n            <a role="button" class="task__edit_btn js_editTask">Edit</a>\n            <p class="task__title">' + item.taskTitle + '</p>\n            <p class="task__message">' + item.taskMessage + '</p>\n        </div>\n    ';
};

var attachEventListener = function attachEventListener() {

    // attach click event to "EDIT" buttons which are created dynamically

    var itemsWrapper = document.querySelector('.js_tasksWrapper');

    itemsWrapper.addEventListener('click', function (e) {
        if (e.target.classList.contains('js_editTask')) {
            editItem(e.target.closest('.task').dataset.id);
        }
    });
};

var editItem = function editItem(id) {

    // when the edit button is clicked, get the id of the task
    // find the item with that id in the tasks array an d get it's keys and values
    // loop through the keys (exclude id and timestamps)
    // repopulate the form elements based on the name="key" attribute

    editingItemId = Number(id);
    var itemData = tasks.find(function (x) {
        return x.id === editingItemId;
    });
    var form = document.querySelector('.js_form');
    var objectKeys = Object.keys(itemData);
    var objectValues = Object.values(itemData);

    console.log(objectKeys);

    objectKeys.forEach(function (key, index) {

        if (['id', 'entryTimestamp', 'lastEditTimestamp'].includes(key)) return;

        var element = form.querySelector('[name="' + key + '"]');
        var value = objectValues[index];
        element.value = value;
    });
};

var filterResults = function filterResults() {

    var form = document.querySelector('.js_filtersForm');
    var tasksWrapper = document.querySelector('.js_tasksWrapper');
    var filterByDate = form.querySelector('.js_filterByDate');
    var filterByMarker = form.querySelector('.js_filterByMarker');

    filterByMarker.addEventListener('change', function (e) {

        // every time the value changes
        // reset the tasksWrapper className

        var value = e.target.value;
        tasksWrapper.className = 'wrapper__tasks js_tasksWrapper show-' + value + '-markers';
    });

    filterByDate.addEventListener('change', function (e) {

        // every time da value get change, reverse the tasks array
        // update the global dateSort variable (needed for later use)
        // empty the tasksWrapper innerHTML and rebuild it inside buildItemList

        dateSort = e.target.value;
        tasks.reverse();
        tasksWrapper.innerHTML = '';
        buildItemList(true);
    });
};

getItemData();
attachEventListener();
filterResults();
buildItemList(true);
//# sourceMappingURL=scripts.min.js.map